# 플립플롭이란
전원이 공급되는 한, 상태의 변화를 위한 신호(클럭)가 발생할 떄까지 현재의 상태를 유지하는 논리회로입니다.
레지스터를 구성하는 기본 소자로 2개의 NAND 또는 NOR 게이트를 이용하여 구성합니다.



![스크린샷 2022-03-29 오후 5 06 25](https://user-images.githubusercontent.com/67586085/160564045-aa8c1450-70b6-4588-8208-d6af5fe6b404.png)


D는 데이터 입력
CP는 쓰기
Q는 데이터 출력이라는 표현으로 대체하겠습니다.


종이에 정보를 적어두는 것과 마찬가지로 쓰기 신호는 데이터 입력이 회로에 저장될 수 있도록 하는 것입니다.
보통 쓰기 신호는 0의 값을 가지고 있으므로 입력의 변화가 출력에 대하여 영향을 끼치지 못합니다.
입력값을 플립플롭에 저장하기 위해서는 쓰기 입력을 1로 바꾸었다가 다시 0으로 변경하면 됩니다.
14장에서 언급한 것과 마찬가지로 이런 형태의 회로의 경우 데이터 값의 변화를 막을 수 있기 때문에 <래치>라고 부릅니다.


다음과 같이 간단히 표현할 수도 있습니다.

![latch](https://user-images.githubusercontent.com/67586085/160565187-a87de87b-5c7e-44eb-8664-9773c5626b94.jpeg)

이를 여러개묶어서 다음과 같이 표현할 수도 있습니다.

![images](https://user-images.githubusercontent.com/67586085/160565438-2effa240-37b1-494c-a3fc-bf95e3306237.png)


쓰기라는 이름의 입력을 가지고 있는데 이값은 보통 '0'이 됩니다.
8비트 값을 이 래키에 저장하려면 쓰기 입력을 '1'로 바꾸었다가 다시 '0'으로 변경하면 됩니다.


다음과 같이 하나의 상자로 묶어서 표현할 수 있습니다.

8개의 입력으로부터 선택을 하려고 한다면 2^3 = 8 이므로 3개의 스위치가 필요합니다.

각각의 스위치가 열리고 닫힘으로 어떤 값이 연결될 것인지가 결정됩니다.

이전 챕터들은 2:1 선택기를 다뤘다면 여기서는 8:1 선택기가 됩니다.


![Block-Diagram-of-8-to-1-Multiplexer](https://user-images.githubusercontent.com/67586085/160569134-cba91447-26a7-4a14-a64b-093923ad7b2b.jpeg)


S1, S2, S3를 세자리수의 이진수라고 했을 때

켜지고 꺼짐에 따라 000 ~ 111 총 8개의 경우의 수가 나오게되고 이는 각각의 출력으로 연결됩니다.

8:1 선택기는 인버터 3개, 4입력 AND 게이트 8개, 9입력 OR 게이트 1개로 이루어져 있습니다.


![KakaoTalk_Photo_2022-03-29-17-42-46](https://user-images.githubusercontent.com/67586085/160571163-a8117c33-b574-4364-8cd3-708279cc20fc.jpeg)

결과적으로 101의 경우 출력은 D5의 값과 같아지는 것입니다.


# 입력
지금까지 출력이었습니다. 
다음은 입력부분을 보겠습니다.

출력은 하나 였지만 입력부분에서는 데이터 입력 신호와 쓰기 입력 신호가 있습니다.

출력과 반대 동작을 해야하는 회로가 필요합니다.

이를 3-8디코더 라고 합니다.

![img](https://user-images.githubusercontent.com/67586085/160573112-33562497-f59b-4292-82a8-081c744b2e0f.png)

8개의 출력을 가지고 있습니다.

이 회로는 하나의 출력을 제외하면 다른 출력은 모두 0인 특성을 가지고 있습니다.

다음 그림은 지금까지 배웠던 입력과 출력을 합쳐서 8개의 래치를 포함하고 있는 완전한 회로의 모습입니다.

(_사진_)


여기서 주소는 어떤 래치에 데이터 입력값이 저장되도록 쓰기 신호를 변경시킬지 판단하기 위해 입력으로 사용됩니다.

그림 아래 출력들에서 출력은 8:1 선택기를 조작하여 8개 래치의 출력 중에 한 값을 선택할 수 있도록 하기 위해서 사용됩니다.

이러한 형태를 임의 접근 메모리 즉, 흔히 우리가 알고있는 램(RAM)이라고 부릅니다.

램에서는 개개의 1비트값 8개를 저장할 수 있습니다.

이를 줄여서  8 x 1 (Eight by One)형태라 이야기합니다.

다음과 같이 이를 이어붙여서 2개의 8x1램에 같은 주소값이 입력되게 할 수도 있습니다.

![kkjkjkj](https://user-images.githubusercontent.com/67586085/160594313-b7d3f72b-89ce-4ed0-9e97-a91378b17391.jpeg)


이를 간략하게 다음처럼 그릴 수 있습니다.


![sdfsdf](https://user-images.githubusercontent.com/67586085/160594130-34abd02e-c978-4819-9429-1a9d0dd1ccaa.jpeg)

주소와 쓰기 입력이 두개의 8x1 배열에 공통적으로 연결되어있으므로 8개의 값을 저장한다는 점은 동리하지만 각각의 값이 2비트 크기를 가지게 됩니다.

8 x 2가 아닌 16 x 1 로 만들고 싶다면 선택입력을 추가로 두어 디코더와 선택기 모두에 전달하여 두개의 8 x 1램 중에서 한개를 선택하여 만들 수 있습니다. 이 경우 1비트값을 16개 저장할 수 있게 됩니다.


주소입력이 1비트라면 2개의 값을 저장할 수 있고 2비트라면 4개의 값을 저장할 수 있습니다. 따라서 다음과 같은 표현식으로 나타낼 수 있습니다.

> RAM 배열에 저장되는 값의 수 = 2^주소 입력의 비트수

ㅇㄹㄴㅇㄹㄴㅇㄹㄴㅇㄹㄴㅇㄹㄴ


조금 더 큰 메모리를 살펴보겠습니다.

![asd](https://user-images.githubusercontent.com/67586085/160602295-57138439-1743-465f-ab1c-9357076f93cd.jpeg)

위 RAM배열은 8비트 값을 보두 1024개 저장할 수 있도록 구성되어 있습니다.

8비트는 1바이트 이므로 1024바이트를 저장할 수 있다는 뜻입니다.

1킬로바이트는 1024바이트와 같습니다. 1000과 근사하기 떄문에 1000단위인 킬로가 붙습니다.

> 2^10 vs 10^3


DI는 데이터 입력
W는 쓰기
DO는 데이터 출력


